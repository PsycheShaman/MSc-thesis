---
title: "Thesis: Exploratory Data Analaysi"
author: "Gerhard Viljoen"
date: "11/25/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message = F, warning = F)
```

```{r}
require(reticulate)
```

#Python code for creating a JSON file from Dictionary Objects

```{python,python.reticulate=F,eval=F}
"""
This script extracts Python Dictionaries with Tracklet information 
"""

import os
from ast import literal_eval
import json

os.chdir("/Users/gerhard/MSc-thesis/data")

dat_files = os.listdir("/Users/gerhard/MSc-thesis/data")
dat_files.pop(16)

for i in range(0,len(dat_files)):
        print(dat_files[i])
        d = open(dat_files[i])
        d = d.read()
        d = literal_eval(d)
        jayson = json.dumps(d,indent=4,sort_keys=True)
        name1="dat"
        name2=".json"
        name=name1+str(i)+name2
        outfile = open(name,"w")
        outfile.write(jayson)
```

#Plotting energy deposit in a single detector pad

##As a heatmap

```{r}
setwd("~/MSc-thesis/testdict")

require(jsonlite)

test.dict <- fromJSON("test.json")

an.image <- test.dict$`0`$layer0

image(an.image)
```

##As a filled contour map

```{r}
filled.contour(an.image,color.palette = heat.colors)
```

##Plotting a detector pad's energy deposit, next to the transpose of the same matrix

```{r}
par(mfrow=c(2,2))

L=2

for(i in 1:L){
  
  a <- test.dict[[i]]$layer0
  
  if(is.null(a)==F & is.null(ncol(a))==F & is.null(nrow(a))==F){
    
      image(t(a))
      image(a)
      # filled.contour(a,color.palette = heat.colors,plot.title = title(paste0("Event: ",test.dict[[i]]$Event," TrackID: ",test.dict[[i]]$V0TrackID," PDG Code:",
      #                                                                  test.dict[[i]]$pdgCode)))
    
  }
    


  
}

```

#Plot 3D histograms

##Unscaled 3D Surface Plot

```{r}

require(plotly)
require(plot3D)

a <- test.dict[[1]]$layer0

plotly::plot_ly(z=~a) %>% add_surface()

```

##Normalized and standardized 3D Surface Plot

```{r}
plotly::plot_ly(z=~scale(a)) %>% add_surface()

```

##Three examples of pion energy deposition 3D histograms

```{r}

L <- length(test.dict)
count.pion <- 0
count.electron <- 0


for(i in 1:L){
  a <- test.dict[[i]]$layer0
  
  if(is.null(a)==F & is.null(ncol(a))==F & is.null(nrow(a))==F & sum(a)!=0 & count.pion < 3){
  
  if(test.dict[[i]]$pdgCode==211 | test.dict[[i]]$pdgCode==-211){
    count.pion <- count.pion+1
  
hist3D(z=a)
  }

}

}

```

##Three examples of electron energy deposition 3D Histograms

```{r}


for(i in 1:L){
  a <- test.dict[[i]]$layer0
  
  if(is.null(a)==F & is.null(ncol(a))==F & is.null(nrow(a))==F & count.electron < 3){

  
  if(test.dict[[i]]$pdgCode==11 | test.dict[[i]]$pdgCode==-11){
        count.electron <- count.electron + 1
  hist3D(z=a)


  }

}

}

```

#Read in 100 python dictionaries

(memory intensive so commented out here)

```{r}
# rm(list=ls())
# setwd("~/MSc-thesis/data")
# require(jsonlite)
# require(readtext)
# 
# #PDG codes
# pdg.elec <- c(11,-11)
# pdg.pion <- c(-211,211)
# 
# files <- list.files(path="~/MSc-thesis/data", pattern="*json", full.names=T, recursive=FALSE)
# 
# j <- fromJSON(files[1])
# 
# for(i in 2:length(files)){
# 
#   f <- fromJSON(files[i])
#   j <- c(j,f)
# }
```

#Split combined JSON out into 2 separate JSON objects for protons & electrons

(memory intensive so commented out here)

##Electrons

```{r}
# electrons <- numeric(264)
# 
# L <- length(j)
# 
# for(i in 1:L){
# 
#   a <- j[[i]]$layer0
# 
# 
#   if(is.null(a)==F & is.null(ncol(a))==F & is.null(nrow(a))==F & sum(unlist(a)) != 0){
# 
# 
#   if(j[[i]]$pdgCode==11 | j[[i]]$pdgCode==-11){
#     a <- as.vector(j[[i]]$layer0)
#     electrons <- rbind(electrons,a)
# 
#   }
# 
# }
# 
# }
# 
# electrons <- as.data.frame(electrons)
# electrons <- electrons[-1,]
# write.csv(electrons,"electrons100.csv")
```


##Pions

```{r}
# pions <- numeric(264)
# 
# L <- length(j)
# 
# for(i in 1:L){
# 
#   a <- j[[i]]$layer0
# 
#   if(is.null(a)==F & is.null(ncol(a))==F & is.null(nrow(a))==F & sum(unlist(a)) != 0){
# 
# 
#   if(j[[i]]$pdgCode==211 | j[[i]]$pdgCode==-211){
# a <- as.vector(j[[i]]$layer0)
#     pions <- rbind(pions,a)
# 
#   }
# 
# }
# 
# }
# 
# pions <- as.data.frame(pions)
# pions <- pions[-1,]
# 
# write.csv(pions,"pions100.csv")

```

#Clean up environment

```{r}

rm(list=ls())

e <- read.csv("electrons100.csv")
p <- read.csv("pions100.csv")
```

#Some high-level stats

##Distribution of energy deposition in a detector pad:

Pions are plotted in blue, electrons in red

```{r}
e <- e[,-1]
mean.electron.e.dep.pad <- rowMeans(e)
p <- p[,-1]
mean.pion.e.dep.pad <- rowMeans(p)

plot(density(mean.pion.e.dep.pad),col="blue",main="Blue = Pions; Red = Electrons",sub= "Electron v Pion: Energy deposit per pad distribution",xlab = "Average energy deposition per PID: dashed lines")
lines(density(mean.electron.e.dep.pad),col="red")
abline(v=mean(mean.pion.e.dep.pad),lty="dashed",col="blue")
abline(v=mean(mean.electron.e.dep.pad),lty="dashed",col="red")
```

#Averaged pad data

##Electron

```{r}
electron.pad <- numeric(264)


for(i in 1:nrow(e)){
  this.pad <- unlist(e[i,])
  
  electron.pad <- electron.pad + this.pad
}

electron.pad <- matrix(electron.pad,nrow=24,byrow=T)
filled.contour(electron.pad,color.palette = heat.colors)
```

##Pion

```{r}
pion.pad <- numeric(264)


for(i in 1:nrow(p)){
  this.pad <- unlist(p[i,])
  
  pion.pad <- pion.pad + this.pad
}

pion.pad <- matrix(pion.pad,nrow=24,byrow=T)
filled.contour(pion.pad,color.palette = heat.colors)
```


```{r}
filled.contour(scale(electron.pad),color.palette = heat.colors)
filled.contour(scale(pion.pad),color.palette = heat.colors)
```

#Plot 100 electron traces:

```{r}
par(mfrow=c(2,5))
for(i in 1:100){
  this.pad <- unlist(e[i,])
  this.pad <- matrix(this.pad,nrow=24,byrow=T)
  image(this.pad)
  
}


```


#Plot 100 pion traces:

```{r}
par(mfrow=c(2,5))
for(i in 1:100){
  this.pad <- unlist(p[i,])
  this.pad <- matrix(this.pad,nrow=24,byrow=T)
  image(this.pad)
  
}


```

#Try to figure out the path a particle takes

##By fitting a linear regression line through a 3D scatterplot of pad data

```{r}
require(plotly)

z <- unlist(e[1,])
y <- rep(1:24,11)
x <- rep(1:11,24)
dat <- cbind(x,y,z)

dat <- data.frame(dat)
names(dat) <- c("x","y","z")

linmod <- lm(z~x+y,dat)

l <- predict(linmod,dat)

l <- matrix(l,nrow=24,byrow = T)

plot_ly(dat,x=~x,y=~y,z=~z) %>% add_markers() %>%
  add_surface(z=~l)
```


```{r}

```

















