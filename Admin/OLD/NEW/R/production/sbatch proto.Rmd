---
title: "sbatch"
author: "Gerhard Viljoen"
date: "4/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Sbatch executable setup

```{r,eval=F}
require(jsonlite, lib.loc = "/scratch/vljchr004/")


args = commandArgs(TRUE)
dirX = args[1]
input2 = args[2]

if(!file.exists(dirX)|!file.exists(input2)){
   cat('Cannot find', input_path, 'exiting!\n')
   stop()
}
```

#Json wrangling (non-hardcoded)

```{r}
#test

dirX="/Users/gerhard/msc-thesis-data/gridtest"
```


```{r}
wrangle <- function(dirX){
  
  require(jsonlite)
  
  files <- list.files(path=paste0(dirX),
                      pattern="*json",
                      full.names=T,
                      recursive=TRUE)
  
  j <- fromJSON(files[1])
  
  print("---------------------------------------------------------------------------------")
  print(paste0("Processing jsons to list:"))
  
  for(i in 2:length(files)){
    print(100*(i/length(files)))
    
    f <- fromJSON(files[i])
    j <- c(j,f)
  }
  
  j
  
}

dat <- wrangle(dirX)
print("---------------------------------------------------------------------------------")
print("DONE")
```

```{r}
print("---------------------------------------------------------------------------------")
print("Extracting layers and momenta...")

p <- sapply(dat,`[[`,"P")
pdg <- sapply(dat, `[[`,"pdgCode")
layer_0 <- sapply(dat, `[[`,"layer 0")
layer_1 <- sapply(dat, `[[`,"layer 1")
layer_2 <- sapply(dat, `[[`,"layer 2")
layer_3 <- sapply(dat, `[[`,"layer 3")
layer_4 <- sapply(dat, `[[`,"layer 4")
layer_5 <- sapply(dat, `[[`,"layer 5")

print("---------------------------------------------------------------------------------")
print("Removing NULLS")

n <- unique(
  c(
  which(sapply(layer_0, is.null)),
  which(sapply(layer_1, is.null)),
  which(sapply(layer_2, is.null)),
  which(sapply(layer_3, is.null)),
  which(sapply(layer_4, is.null)),
  which(sapply(layer_5, is.null))
  )
  )

pdg <- pdg[-n]

layer_0 <- layer_0[-n]

layer_1 <- layer_1[-n]

layer_2 <- layer_2[-n]

layer_3 <- layer_3[-n]

layer_4 <- layer_4[-n]

layer_5 <- layer_5[-n]

p <- p[-n]

print("---------------------------------------------------------------------------------")
print("Removing empties:")

e <- unique(
  
  as.numeric(which(sapply(layer_0, "typeof")=="list")),
  as.numeric(which(sapply(layer_1, "typeof")=="list")),
  as.numeric(which(sapply(layer_2, "typeof")=="list")),
  as.numeric(which(sapply(layer_3, "typeof")=="list")),
  as.numeric(which(sapply(layer_4, "typeof")=="list")),
  as.numeric(which(sapply(layer_5, "typeof")=="list"))
  
)

pdg <- pdg[-e]

layer_0 <- layer_0[-e]

layer_1 <- layer_1[-e]

layer_2 <- layer_2[-e]

layer_3 <- layer_3[-e]

layer_4 <- layer_4[-e]

layer_5 <- layer_5[-e]

p <- p[-e]
```


```{r}
if(length(layer_0)==length(layer_1) &&
  length(layer_1) ==length(layer_2) &&
  length(layer_2)==length(layer_3)&&
  length(layer_3)==length(layer_4)&&
  length(layer_4)==length(layer_5)){

print("Layer dimensions check out")
  x <- array(dim=c(1,17,24,6))
    
}else{
    print("Layers are not same dimensions, stopping")
  stop()
  }

```

```{r}
require(abind)
for(i in 1:length(layer_0)){
  a <- array(data=c(
    
    layer_0[[i]], 
    layer_1[[i]], 
    layer_2[[i]], 
    layer_3[[i]], 
    layer_4[[i]], 
    layer_5[[i]]
    
  ),
  dim = c(17,24,6)
  )
  
  x <- abind(x,a,along = 1)
}

x <- x[-1,,,]

if(dim(x)[2]==17 &&
   dim(x)[3]==24 &&
   dim(x)[4]==6 &&
  dim(x)[1]==length(layer_0)){
  require(keras, lib.loc = "/scratch/vljchr004/")
}else{
  print("Array building seems to not have went well, stopping")
  stop()
  
}
```

```{r}
y <- as.vector(ifelse(abs(as.numeric(pdg))==211,1,0))
y <- to_categorical(y)

as.numeric(pdg[1])
#[1] 211
y[1,]
#[1] 0 1

#therefore column 1 will be 1 if pion, 0 if electron
#column 2 will be 1 if electron, 0 if pion
```



```{r}
y <- as.vector(ifelse(abs(as.numeric(pdg))==211,1,0))
y <- to_categorical(y)


cnn_model <- keras_model_sequential()

cnn_model %>%
  
  #layer conv 1
  
  layer_conv_2d(filter=32,
                kernel_size=c(3,3),
                padding="same",
                input_shape=c(17,24,6) ) %>%  
  
  layer_activation("relu") %>%  
  
  #layer conv 2
  
  layer_conv_2d(filter=32 ,
                kernel_size=c(3,3)) %>%
  
  layer_activation("relu") %>%
  
  #max pooling layer

  layer_max_pooling_2d(pool_size=c(2,2)) %>%  
  
  #dropout layer to avoid overfitting
  
  layer_dropout(0.25) %>%
  
  layer_conv_2d(filter=32 ,
                kernel_size=c(3,3),
                padding="same") %>%
  
  layer_activation("relu") %>%
  
  layer_conv_2d(filter=32,kernel_size=c(3,3) ) %>%
  
  layer_activation("relu") %>%  
  
  
  layer_max_pooling_2d(pool_size=c(2,2)) %>%  
  layer_dropout(0.25) %>%
  
  #flatten the input  
  layer_flatten() %>%  
  
  layer_dense(512) %>%  
  layer_activation("relu") %>%  
  
  layer_dropout(0.5) %>%  
  
  #output layer-10 classes-10 units  
  layer_dense(10) %>%  
  
  #applying softmax nonlinear activation function to the output layer #to calculate cross-entropy  
  
  layer_activation("softmax") 

#for computing Probabilities of classes-"logit(log probabilities)

#Model's Optimizer

#defining the type of optimizer-ADAM-Adaptive Momentum Estimation

opt<-optimizer_adam( lr= 0.0001 , decay = 1e-6 )

#lr-learning rate , decay - learning rate decay over each update


cnn_model %>%
  compile(loss="categorical_crossentropy",
          optimizer=opt,metrics = "accuracy")

#Summary of the Model and its Architecture
summary(cnn_model)


#training and test:

set.seed(123456)

train_ind <- base::sample(1:dim(x)[4],size = round(0.75*dim(x)[4]),replace = F)

x_train <- x[,,,train_ind]
y_train <- y[train_ind]

test_ind <- 1:dim(x)[4]
test_ind <- test_ind[-train_ind]

x_test <- x[,,,test_ind]
y_test <- y[test_ind]

d <- numeric(dim(x)[1])
  
for(i in 1:dim(x)[1]){
  
  a <- as.vector(dim(x[i,,,]))==c(17,24,6)
  
  if(all(a)){
    d[i] <- 1
  }
  else{d[i] <- -1}
    
  
}

history <- cnn_model %>%
  fit(x_train,
      y_train,
      batch_size=64,
      epochs=100,
      validation_split=0.3)

all(d==1)

png("/home/vljchr004/cnn_model_1.png")

plot(history)

dev.off()
```










